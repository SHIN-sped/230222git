5.1 프로젝트 설정 - 콘트롤러 클래스에 @RestController와 @RequestMapping 설정

5.2 GET API 만들기
5.2.1 @RequestMapping으로 구현하기 - @RequestMapping을 사용한 메서드 구현
5.2.2 매개변수가 없는 GET 메서드 구현 - 매개변수가 없는 GET 매서드 구현
5.2.3 @PathVariable을 활용한 GET 메서드 구현 - @PathVariable을 활용한 GET 메서드 구현, @PathVariable에 변수명을 매핑하는 방법
5.2.4 @RequestParam을 활용한 GET 메서드 구현 - 딕셔너리 키값, 쿼리 형식, @RequestParam을 활용한 GET 메서드 구현, @RequestParam과 Map을 조합한 GET 메서드 구현
5.2.5 DTO 객체를 활용한 GET 메서드 구현 - DTO 클래스의 예, DTO 객체를 활용한 GET 메서드 구현

5.3 POST API 만들기
5.3.1 @RequestMapping으로 구현하기 - @RequestMapping 사용 예
5.3.2 @RequestBody를 활용한 POST 메서드 구현 - @RequestBody와 Map을 활용한 POST 메서드 구현

5.4 PUT API 만들기
5.4.1 @RequestBody를 활용한 PUT 메서드 구현 - @RequestBody와 Map을 활용한 PUT 메서드 구현, DTO 객체를 활용한 PUT메서드 구현
5.4.2 ResponseEntity를 활용한 PUT 메서드 구현 - ResponseEntity를 활용한 PUT 메서드 구현

5.5 DELETE API 만들기 - DeleteController 클래스
5.5.1 @PathVariable과 @RequestParam을 활용한 DELETE 메서드 구현 - @PathVariable을 활용한 DELETE 메서드 구현, @RequestParam을 활용한 DELETE 메서드 구현

5.6 [한걸음 더] REST API 명세를 문서화하는 방법 - Swagger, pom-xml 파일에 Swagger 의존성 추가, Swagger 설정 코드, 기존 코드에 Swagger 명세를 추가

5.7 [한걸음 더] 로깅 라이브러리 - Logback
5.7.1 Logback 설정 - Logback 설정 파일 예시
5.7.2 Logback 적용하기 - Logger 선언, 로그 출력 코드 삽입, 변수의 값을 로그로 출력

5.8 정리 

6.1 마리아DB 설치

6.2 ORM

6.3 JPA

6.4 하이버네이트
6.4.1 Spring Data JPA

6.5 영속성 컨텍스트
6.5.1 엔티티 매니저 - SimpleJpaRepository의 EntityManager 의존성 주입 코드, 엔티티 매니저 팩토리 사용을 위한 
6.5.2 엔티티의 생명주기


6.6 데이터베이스 연동
6.6.1 프로젝트 생성 - SwaggerConfiguration 코드 수정, application.properties 파일에 데이터베이스 관련 설정 추가

6.7 엔티티 설계 - 엔티티 클래스
6.7.1 엔티티 관련 기본 어노테이션

6.8 리포지토리 인터페이스 설계
6.8.1 리포지토리 인터페이스 생성 - 리포지토리 생성, JpaRepository에서 제공하는 기본 메서드
6.8.2 리포지토리 메서드의 생성 규칙

6.9 DAO 설계
6.9.1 DAO 클래스 생성 - ProductDAO 인터페이스, ProductDAO 인터페이스의 구현체 클래스, insertProduct() 메서드, selectProduct() 메서드, SimpleJpaRepository의 getById() 메서드, SimpleJpaRepository의 findById() 메서드, updateProductName() 메서드, SimpleJpaRepository의 save() 메서드, deleteProduct() 메서드, SimpleJpaRepository의 delete() 메서드

6.10 DAO 연동을 위한 컨트롤러와 서비스 설계
6.10.1 서비스 클래스 만들기 - ProductDto 클래스, ProductResponseDto 클래스, ProductService 인터페이스 설계, 서비스 인터페이스 구현체 클래스, getProduct() 메서드 구현, saveProduct() 메서드 구현, changeProductName() 메서드 구현
6.10.2 컨트롤러 생성 - ProductController 클래스, ChangeProductNameDto
6.10.3 Swagger API를 통한 동작 확인

6.11 [한걸음 더]반복되는 코드의 작성을 생략하는 방법 - 롬복
6.11.1 롬복 설치 - 롬복 의존성 추가
6.11.2 롬복 적용 - Product 엔티티 클래스, 롬보이 적용된 Product 엔티티 클래스
6.11.3 롬복의 주요 어노테이션 - @Getter/@Setter로 자동 생성되는 매서드, Product 클래스의 생성자 자동 생성, 자동생성되는 toString() 메서드, @ToString 어노테이션의 exclude 속성 활용, 자동 생성되는 equals()와 hashCode()메서드, @EqualsAndHashCode의 callSuper 속성 사용

7.1 테스트 코드를 작성하는 이유

7.2 단위 테스트와 통합 테스트
7.2.1 단위 테스트의 특징
7.2.2 통합 테스트의 특징

7.3 테스트 코드를 작성하는 방법
7.3.1 Given-When-Then 패턴
7.3.2 좋은 테스트를 작성하는 5가지 속성(F.I.R.S.T)

7.4 Junit을 활용한 테스트 코드 작성
7.4.1 JUnit의 세부 모듈
7.4.2 스프링 부트 프로젝트 생성 - ProductServicempl 클래스 수정, Product 엔티티 클래스
7.4.3 스프링 부트의 테스트 설정 - pom.xml 파일에 spring-boot-starter-test 의존성 추가
7.4.4 JUnit의 생명주기 - 테스트 생명주기 예제
7.4.5 스프링 부트에서의 테스트
7.4.6 컨트롤러 객체의 테스트 - ProductController의 getProduct() 메서드, getProduct() 메서드에 대한 테스트, createProduct() 메소드에 대한 테스트
7.4.7 서비스 객체의 테스트 - saveProduct() 메서드의 단위 테스트, @MockBean 어노테이션을 사용한 테스트 환경 설정
7.4.8 리포지토리 객체의 테스트 - 프로젝트 DB연결과 관련, H2 DB에 대한 의존성 추가, 데이터베이스 저장 테스트, 데이터베이스 조회 테스트, 테스트 데이터베이스 변경을 위한 어노테이션 추가, @SpringBootTest 어노테이션을 활용한 테스트

7.5 JaCoCo를 활용한 테스트 커버리지 확인
7.5.1 JaCoCo 플러그잊 설정 - pom.xml 파일에 JaCoCo 플러그인 축가, <Configuration> 설정, <executions> 설정, JaCoCo Configuration 설정
7.5.2 JaCoCo 테스트 커버리지 확인

7.6 테스트 주도 개발(TDD)
7.6.1 테스트 주도 개발의 개발 주기
7.6.2 테스트 주도 개발의 효과
7.7 정리






































































